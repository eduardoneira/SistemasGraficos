<!doctype html>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<meta content="UTF-8" http-equiv="encoding">
<script src="scripts/object3d.js"></script>
<script src="scripts/utils.js"></script>
<script src="scripts/cylinder.js"></script>
<script src="scripts/texture_handler.js"></script>
<script src="gl-matrix.js"></script>

<html>
  <head>
    <title>66.71 WebGL FrameWork</title>
    <style>
      body{ background-color: grey; }
      canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
    </style>

    <script type="text/javascript" src="gl-matrix.js"></script>
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aVertexTextureCoord;

      uniform mat4 uVMMatrix;
      uniform mat4 uPMatrix;

			varying highp vec2 vTextureCoord;

      void main(void) {
          gl_Position = uPMatrix * uVMMatrix * vec4(aVertexPosition, 1.0);
          vTextureCoord = aVertexTextureCoord;
      }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
      varying highp vec2 vTextureCoord;

      uniform sampler2D uSampler;

      void main(void) {
        gl_FragColor = texture2D(uSampler,vTextureCoord);
      }
    </script>

    <script>
      var gl = null,
          canvas = null,
          glProgram = null,
          fragmentShader = null,
          vertexShader = null,
          t = 0.0;
					cylinder = null;

      var vMatrix = mat4.create();
      var pMatrix = mat4.create();

       // SHADERS FUNCTION
      function getShader(gl, id) {
        var shaderScript, src, currentChild, shader;

        // Obtenemos el elemento <script> que contiene el código fuente del shader.
        shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        // Extraemos el contenido de texto del <script>.
        src = "";
        currentChild = shaderScript.firstChild;
        while(currentChild) {
            if (currentChild.nodeType == currentChild.TEXT_NODE) {
                src += currentChild.textContent;
            }
            currentChild = currentChild.nextSibling;
        }

        // Creamos un shader WebGL según el atributo type del <script>.
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        // Le decimos a WebGL que vamos a usar el texto como fuente para el shader.
        gl.shaderSource(shader, src);

        // Compilamos el shader.
        gl.compileShader(shader);  
          
        // Chequeamos y reportamos si hubo algún error.
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
          alert("An error occurred compiling the shaders: " + 
                gl.getShaderInfoLog(shader));  
          return null;  
        }
          
        return shader;
      }

      function initWebGL()
      {
        canvas = document.getElementById("my-canvas");  
        try{
            gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");                    
        }catch(e){
        }
                        
        if(gl)
        {
            setupWebGL();
            initShaders();
            loadTextures();
            createScene();
            setInterval(drawScene, 10);  
        }else{    
            alert(  "Error: Your browser does not appear to support WebGL.");
        }
      }
      
      function setupWebGL()
      {
        //set the clear color
        gl.clearColor(0.1, 0.1, 0.2, 1.0);     
        gl.enable(gl.DEPTH_TEST);                              
        gl.depthFunc(gl.LEQUAL); 
        gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
        
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      
      function initShaders()
      {
        // Obtenemos los shaders ya compilados
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        // Creamos un programa de shaders de WebGL.
        glProgram = gl.createProgram();

        // Asociamos cada shader compilado al programa.
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);

        // Linkeamos los shaders para generar el programa ejecutable.
        gl.linkProgram(glProgram);

        // Chequeamos y reportamos si hubo algún error.
        if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
          alert("Unable to initialize the shader program: " + 
                gl.getProgramInfoLog(glProgram));
          return null;
        }

        // Le decimos a WebGL que de aquí en adelante use el programa generado.
        gl.useProgram(glProgram);
      }
      
      function makeShader(src, type)
      {
        //compile the vertex shader
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      // read from folder all textures
      function loadTextures() {
        textures["cylinder"] = loadTexture(gl,"resources/cylinder2.png");
      }
      
      function createScene() {
        cylinder = new Cylinder(40,40,textures["cylinder"],2);
        cylinder.init();
      }

      var identity = mat4.create();
      
      function drawScene()
      {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
        mat4.perspective(pMatrix, 45, 640.0/480.0, 0.1, 100.0);
        gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);

        mat4.identity(vMatrix);
        mat4.translate(vMatrix, vMatrix, [0.0, 0.0, -20.0]);
        mat4.rotate(vMatrix,vMatrix,t, [1.0, 0.0, 0.0]);
        
        t = t + 0.01;

        cylinder.draw(identity);
      }
    </script>
  </head>
  <body onload="initWebGL()">
		<center>
			<h1>Sistemas Gráficos - 66.71</h1>
			<h2>WebGL - Grilla de vértices</h2>
			<canvas id="my-canvas" width="900" height="500">
			Your browser does not support the HTML5 canvas element.
			</canvas>
		</center>
  </body>
</html>